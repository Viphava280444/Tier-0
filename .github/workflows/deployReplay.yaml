name: Pipeline for deploy the replay

on:
  # push:
  #   branches: [ "Pipeline" ]
  workflow_dispatch:          
    inputs:                  
      message1:               
        description: 'URL to download with wget'
        required: true         
        default: 'https://raw.githubusercontent.com/Viphava280444/Tier-0/6c527ebb930cf7f306acf7e0bf83d5da869438b7/etc/ReplayOfflineConfiguration.py'

      Replay:
        description: 'Choose the Replay'
        required: true
        type: choice
        options:
        - 'vocms047'
        - 'vocms0500'
        default: 'vocms047'

      Patch:
        description: 'Choose one option to patch'
        required: true
        type: choice
        options:
        - 'Patch'
        - 'No Patch'
        default: 'No Patch'

      message5:
        description: 'Providing the commit number if it need to patch. (5000, 5001)'
        required: false        
        default: '5081'

      message2:               
        description: 'WMCORE Version'
        required: false        
        default: '2.4.0'

      message3:               
        description: 'T0 Version'
        required: false        
        default: '3.4.0'

      message4:               
        description: 'Python Version'
        required: false        
        default: '3.12'

    
jobs:
  deploy-the-replay:
    runs-on: cmst0
    
    steps:
    
    - name: Access to virtual machine and run the script
      env:
        SERVER1_HOST: ${{ secrets.SERVER1_HOST }}
        SERVER1_USER: ${{ secrets.SERVER1_USER }}
        SERVER1_PASS: ${{ secrets.SERVER1_PASS }}
        SERVER2_HOST: ${{ secrets.SERVER2_HOST }}
        SERVER2_USER: ${{ secrets.SERVER2_USER }}
        SERVER2_PASS: ${{ secrets.SERVER2_PASS }}
        WGET_URL: ${{ github.event.inputs.message1 }} 
        REPLAY_OPTION: ${{ github.event.inputs.Replay }}  
        PATCH_OPTION: ${{ github.event.inputs.Patch }}        
        PATCH_URL: ${{ github.event.inputs.message5 }}
        WMCORE_VERSION : ${{ github.event.inputs.message2 }}
        T0_VERSION : ${{ github.event.inputs.message3 }}
        PYTHON_VERSION : ${{ github.event.inputs.message4 }}

      run: |
        # Method 1: Use expect to handle SSH password prompts
        expect << 'EOF'

        set timeout 1800

        # spawn ssh -o StrictHostKeyChecking=no $env(SERVER1_USER)@$env(SERVER1_HOST)
        # expect "*assword*"

        # send "$env(SERVER1_PASS)\r"
        # expect -re {.*\$\s*} { }

        # send "ssh -o StrictHostKeyChecking=no $env(SERVER2_USER)@$env(SERVER2_HOST)\r"
        # expect "*assword*"

        # send "$env(SERVER2_PASS)\r"
        # expect -re {.*\$\s*} { }

        spawn "echo 'Connected to Server2'"
        expect -re {.*\$\s*} { }


        send "$env(REPLAY_OPTION)\r"
        expect -re {.*\$\s*} { }

        send "source env.sh\r"
        expect -re {.*\$\s*} { }

        send "cd /data/tier0/ReplayPipeline\r"
        expect -re {.*\$\s*} { }

        send "rm -f ReplayOfflineConfiguration.py\r"
        expect -re {.*\$\s*} { }

        send "wget '$env(WGET_URL)'\r"
        expect -re {.*\$\s*} { }

        send "CONFIG_FILE=\$(ls *ReplayOfflineConfiguration.py 2>/dev/null | head -1)\r"
        expect -re {.*\$\s*} { }

        send "if \[ ! -z \"\$CONFIG_FILE\" \] && \[ \"\$CONFIG_FILE\" != \"ReplayOfflineConfiguration.py\" \]; then echo \"Renaming \$CONFIG_FILE to ReplayOfflineConfiguration.py\"; mv \"\$CONFIG_FILE\" \"ReplayOfflineConfiguration.py\"; else echo 'Configuration file already named correctly or not found'; fi\r"
        expect -re {.*\$\s*} { }

        send "condor_rm -all\r"
        expect -re {.*\$\s*} { }

        send "stop_agent\r"
        expect -re {.*\$\s*} { }

        send "rm -f /data/tier0/admin/ReplayOfflineConfiguration.py\r"
        expect -re {.*\$\s*} { }

        send "SRC_FILE=/data/tier0/ReplayPipeline/ReplayOfflineConfiguration.py\r"
        expect -re {.*\$\s*} { }

        send "DEST_FILE=/data/tier0/admin/ReplayOfflineConfiguration.py\r"
        expect -re {.*\$\s*} { }

        send "cp \$SRC_FILE \$DEST_FILE\r"
        expect {
            -re {.*\$\s*} { } 
            timeout { puts "Timeout during file copy"; exit 1 }
        }

        send "export WMAGENT_TAG_VAR='$env(WMCORE_VERSION)'\r"
        expect -re {.*\$\s*} { }

        send "export TIER0_VERSION_VAR='$env(T0_VERSION)'\r"
        expect -re {.*\$\s*} { }

        send "export PYTHON_VERSION_VAR='$env(PYTHON_VERSION)'\r"
        expect -re {.*\$\s*} { }

        send "source /data/tier0/ReplayPipeline/00_pypi_deploy_replay.sh\r"
        
        expect "*Are you sure you wish to continue? (Y/n)*"

        send "Y\r"
    
        expect -re {.*\$\s*} { }

        send "echo 'Deployment completed, starting agent...'\r"
        expect -re {.*\$\s*} { }

        send "if \[ \"$env(PATCH_OPTION)\" = \"Patch\" \]; then echo 'Applying patches...'; IFS=',' read -ra PATCHES <<< '$env(PATCH_URL)'; for patch_num in \"\${PATCHES\[@\]\}\"; do patch_num=\$(echo \$patch_num | tr -d ' '); echo \"Applying patch PR #\$patch_num\"; curl https://patch-diff.githubusercontent.com/raw/dmwm/T0/pull/\${patch_num}.patch | patch -f -d /data/tier0/WMAgent.venv3/lib/python$env(PYTHON_VERSION)/site-packages/ -p 3; echo \"Patch \$patch_num applied\"; done; else echo 'No patch requested, skipping...'; fi\r"
        expect -re {.*\$\s*} { }

        send "cp /data/tier0/ReplayPipeline/checkProxy.py /data/tier0/WMAgent.venv3/deploy/checkProxy.py\r"
        expect -re {.*\$\s*} { }

        send "start_agent\r"
        expect -re {.*\$\s*} { }

        send "echo 'Verifying agent status...'\r"
        expect -re {.*\$\s*} { }

        send "timeout 600 tail -f /data/tier0/WMAgent.venv3/srv/wmagent/$env(WMCORE_VERSION)/install/Tier0Feeder/ComponentLog\r"
        expect -re {.*\$\s*} { }

        send "ps aux | grep -E '(wmcore|wmagent)' | grep -v grep || echo 'No WMAgent processes found'\r"
        expect -re {.*\$\s*} { }

        send "echo 'Deployment workflow completed successfully'\r"
        expect -re {.*\$\s*} { }

        EOF